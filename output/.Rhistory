mgmtvars[i]
mdat <- metricdat[metricdat[,mgmtvars[i]]!="none",]
table(mdat[,mgmtvars[i]], mdat$new.metric, mdat$success)
# mdat <- subset(mdat, species!="ruff" & species!="dunlin")
# for the following categories, subset further because there aren't enough observations of either 0,1 or both
#   if (mgmtvars[i]=="reserve.desig") {
#     mdat <- subset(mdat, new.metric!="productivity")
#   }
#   if (mgmtvars[i]=="mowing") {
#     mdat <- subset(mdat, mowing!="applied")
#   }
if (mgmtvars[i]=="grazing") {
mdat <- subset(mdat, new.metric!="abundance/occupancy change")
}
if (mgmtvars[i]=="fertpest") {
mdat <- subset(mdat, fertpest!="applied")
# mdat <- subset(mdat, new.metric!="occupancy")
}
if (mgmtvars[i]=="water") {
# mdat <- subset(mdat, water!="reduced")
# mdat <- subset(mdat, new.metric!="abundance change" & new.metric!="occupancy")
# model runs ok without 2 of curlew, oystercatcher and snipe, but model won't converge and has a very high max|grad| value when more than 1 of these species is included. Since they all have no successes for this management intervention and similar levels of failure, then combine together for the water analysis
# mdat <- subset(mdat, species!="curlew" & species!="oystercatcher")
# mdat$species <- ifelse(mdat$species=="oystercatcher" | mdat$species=="curlew" | mdat$species=="snipe", "OC/CU/SN", as.character(mdat$species))
}
mdat <- droplevels(mdat)
usedat[[i]] <- mdat
(checkzeros[[i]] <- table(mdat[,mgmtvars[i]], mdat$new.metric, mdat$success))
# create different formulas to use depending on whether management variable is 1 or 2 levels
if (length(levels(mdat[,mgmtvars[i]])) > 1) {
#     modform <- as.formula(paste("success ~ ", mgmtvars[i], "*new.metric + (1|reference) + (1|species)", sep=""))
modform <- as.formula(paste("success ~ ", mgmtvars[i], "*new.metric + (1|reference)", sep=""))
}
if (length(levels(mdat[,mgmtvars[i]])) < 2) {
#     modform <- as.formula("success ~ new.metric + (1|reference) + (1|species)")
modform <- as.formula("success ~ new.metric + (1|reference)")
}
# run a normal glmer model
m.ind.sp[[i]] <- glmer(modform, data=mdat, family=binomial, control=glmerControl(optimizer="bobyqa"))
# if ANY checkzeros==0, then there are categories which are missing any observations whatsoever, so will have problems with complete separation and/or convergence
# use bglmer since there are some cases of singularity produced by 0/1 not having any observations for some of the categorical variables
# calculate the dimensions of the covariance matrix for bglmer, based on the dimensions of the covariance matrix from the regular glmer model
# if (any(checkzeros==0)) {
vcov.dim <- nrow(vcov(m.ind.sp[[i]]))
m.ind.sp.blme[[i]] <- bglmer(modform, data=mdat, family=binomial, fixef.prior = normal(cov = diag(9,vcov.dim)), control=glmerControl(optimizer="bobyqa"))
# }
i
mgmtvars[i]
mdat <- metricdat[metricdat[,mgmtvars[i]]!="none",]
table(mdat[,mgmtvars[i]], mdat$new.metric, mdat$success)
# mdat <- subset(mdat, species!="ruff" & species!="dunlin")
# for the following categories, subset further because there aren't enough observations of either 0,1 or both
#   if (mgmtvars[i]=="reserve.desig") {
#     mdat <- subset(mdat, new.metric!="productivity")
#   }
#   if (mgmtvars[i]=="mowing") {
#     mdat <- subset(mdat, mowing!="applied")
#   }
if (mgmtvars[i]=="grazing") {
mdat <- subset(mdat, new.metric!="abundance/occupancy change")
}
if (mgmtvars[i]=="fertpest") {
mdat <- subset(mdat, fertpest!="applied")
}
if (mgmtvars[i]=="water") {
mdat <- subset(mdat, new.metric!="abundance/occupancy change")
}
mdat <- droplevels(mdat)
usedat[[i]] <- mdat
(checkzeros[[i]] <- table(mdat[,mgmtvars[i]], mdat$new.metric, mdat$success))
# create different formulas to use depending on whether management variable is 1 or 2 levels
if (length(levels(mdat[,mgmtvars[i]])) > 1) {
#     modform <- as.formula(paste("success ~ ", mgmtvars[i], "*new.metric + (1|reference) + (1|species)", sep=""))
modform <- as.formula(paste("success ~ ", mgmtvars[i], "*new.metric + (1|reference)", sep=""))
}
if (length(levels(mdat[,mgmtvars[i]])) < 2) {
#     modform <- as.formula("success ~ new.metric + (1|reference) + (1|species)")
modform <- as.formula("success ~ new.metric + (1|reference)")
}
# run a normal glmer model
m.ind.sp[[i]] <- glmer(modform, data=mdat, family=binomial, control=glmerControl(optimizer="bobyqa"))
# if ANY checkzeros==0, then there are categories which are missing any observations whatsoever, so will have problems with complete separation and/or convergence
# use bglmer since there are some cases of singularity produced by 0/1 not having any observations for some of the categorical variables
# calculate the dimensions of the covariance matrix for bglmer, based on the dimensions of the covariance matrix from the regular glmer model
# if (any(checkzeros==0)) {
vcov.dim <- nrow(vcov(m.ind.sp[[i]]))
m.ind.sp.blme[[i]] <- bglmer(modform, data=mdat, family=binomial, fixef.prior = normal(cov = diag(9,vcov.dim)), control=glmerControl(optimizer="bobyqa"))
# }
names(m.ind.sp) <- mgmtvars
names(m.ind.sp.blme) <- mgmtvars
names(usedat) <- mgmtvars
names(checkzeros) <- mgmtvars
warningmessages.lme4 <- lapply(m.ind.sp, function(x) slot(x, "optinfo")$conv$lme4$messages)
warningmessages.lme4
warningmessages.blme <- lapply(m.ind.sp.blme, function(x) slot(x, "optinfo")$conv$lme4$messages)
warningmessages.blme
setwd(outputwd)
sink(paste("model output_0c.txt", sep=" "))
cat("\n########==========  0b) success of individual management types by metric - BLME models (good) ==========########\n", sep="\n")
print(lapply(m.ind.sp.blme, summary))
cat("\n########==========  0b) success of individual management types by metric - lme4 models (convergence issues) ==========########\n", sep="\n")
print(lapply(m.ind.sp, summary))
cat("\n########==========  Warning messages BLME models (good) ==========########\n", sep="\n")
print(warningmessages.blme)
cat("\n########==========  Warning messages lme4 models (convergence issues) ==========########\n", sep="\n")
print(warningmessages.lme4)
sink()
### Save individual interventions models
saveRDS(m.ind.sp.blme, file=paste(workspacewd, "models_0c_blme.rds", sep="/"))
saveRDS(m.ind.sp, file=paste(workspacewd, "models_0c_lme4.rds", sep="/"))
### Save dataset for 0b models
saveRDS(usedat, file=paste(workspacewd, "model dataset_0c.rds", sep="/"))
# identify which categories have low numbers
out <- list()
for(i in 1:length(mgmtvars)) {
out[[i]] <- table(dat$habitat, dat[,mgmtvars[i]])
}
names(out) <- mgmtvars
out
# mgmtvars <- c("AE","AE.level","reserve.desig","nest.protect","water")
### ANALYSIS ###
# identify which categories have low numbers
out <- list()
for(i in 1:length(mgmtvars)) {
out[[i]] <- table(dat$newhabitat, dat[,mgmtvars[i]])
}
names(out) <- mgmtvars
out
# set up list to output models and model datasets to
m.ind.sp <- list()
m.ind.sp.blme <- list()
usedat <- list() # data subset used to run a model
for (i in 1:length(mgmtvars)) {
mgmtvars[i]
mdat <- dat[dat[,mgmtvars[i]]!="none",]
table(mdat[,mgmtvars[i]], mdat$newhabitat, mdat$success)
if (mgmtvars[i]=="AE.level") {
mdat <- subset(mdat, newhabitat!="unenclosed")
}
if (mgmtvars[i]=="mowing") {
mdat <- subset(mdat, newhabitat!="unenclosed")
}
if (mgmtvars[i]=="fertpest") {
mdat <- subset(mdat, newhabitat!="unenclosed")
mdat <- subset(mdat, fertpest!="applied")
}
if (mgmtvars[i]=="water") {
mdat <- subset(mdat, water!="reduced")
}
mdat <- droplevels(mdat)
usedat[[i]] <- mdat
(checkzeros <- table(mdat[,mgmtvars[i]], mdat$newhabitat, mdat$success))
# create different formulas to use depending on whether management variable is 1 or 2 levels
if (length(levels(mdat[,mgmtvars[i]])) > 1) {
modform <- as.formula(paste("success ~ ", mgmtvars[i], "*newhabitat + (1|reference)", sep=""))
}
if (length(levels(mdat[,mgmtvars[i]])) < 2) {
modform <- as.formula("success ~ newhabitat + (1|reference)")
}
# run a normal glmer model
m.ind.sp[[i]] <- glmer(modform, data=mdat, family=binomial, control=glmerControl(optimizer="bobyqa"))
# if ANY checkzeros==0, then there are categories which are missing any observations whatsoever, so will have problems with complete separation and/or convergence
# use bglmer since there are some cases of singularity produced by 0/1 not having any observations for some of the categorical variables
# calculate the dimensions of the covariance matrix for bglmer, based on the dimensions of the covariance matrix from the regular glmer model
# if (any(checkzeros==0)) {
vcov.dim <- nrow(vcov(m.ind.sp[[i]]))
m.ind.sp.blme[[i]] <- bglmer(modform, data=mdat, family=binomial, fixef.prior = normal(cov = diag(9,vcov.dim)), control=glmerControl(optimizer="bobyqa"))
# }
summary(m.ind.sp.blme[[i]])
}
names(m.ind.sp) <- mgmtvars
names(m.ind.sp.blme) <- mgmtvars
names(usedat) <- mgmtvars
warningmessages.lme4 <- lapply(m.ind.sp, function(x) slot(x, "optinfo")$conv$lme4$messages)
warningmessages.lme4
warningmessages.blme <- lapply(m.ind.sp.blme, function(x) slot(x, "optinfo")$conv$lme4$messages)
warningmessages.blme
setwd(outputwd)
sink(paste("model output_0d.txt", sep=" "))
cat("\n########==========  0d) success of individual management types (subset only) by habitat - BLME models (good) ==========########\n", sep="\n")
print(lapply(m.ind.sp.blme, summary))
cat("\n########==========  0d) success of individual management types (subset only) by habitat - lme4 models (convergence issues) ==========########\n", sep="\n")
print(lapply(m.ind.sp, summary))
cat("\n########==========  Warning messages BLME models (good) ==========########\n", sep="\n")
print(warningmessages.blme)
cat("\n########==========  Warning messages lme4 models (convergence issues) ==========########\n", sep="\n")
print(warningmessages.lme4)
sink()
### Save individual interventions models
saveRDS(m.ind.sp.blme, file=paste(workspacewd, "models_0d_blme.rds", sep="/"))
saveRDS(m.ind.sp, file=paste(workspacewd, "models_0d_lme4.rds", sep="/"))
### Save dataset for 0b models
saveRDS(usedat, file=paste(workspacewd, "model dataset_0d.rds", sep="/"))
sppdat <- dat
# identify which categories have low numbers
out <- list()
for(i in 1:length(mgmtvars)) {
out[[i]] <- table(sppdat$species, sppdat[,mgmtvars[i]])
}
names(out) <- mgmtvars
out
# set up list to output models and model datasets to
m.ind.sp <- list()
m.ind.sp.blme <- list()
usedat <- list() # data subset used to run a model
for (i in 1:length(mgmtvars)) {
mgmtvars[i]
mdat <- sppdat[sppdat[,mgmtvars[i]]!="none",]
table(mdat[,mgmtvars[i]], mdat$species, mdat$success)
# for the following categories, subset further because there aren't enough observations of either 0,1 or both
# dunlin and ruff will need to be removed from most categories due to lack of observations, but there may be some with sufficient, or ok if combined
if (mgmtvars[i]=="AE") {
mdat <- subset(mdat, species!="dunlin" & species!="ruff")
}
if (mgmtvars[i]=="AE.level") {
mdat <- subset(mdat, species!="dunlin" & species!="ruff")
}
if (mgmtvars[i]=="reserve.desig") {
mdat <- subset(mdat, species!="dunlin" & species!="ruff")
# mdat$species <- ifelse(mdat$species=="dunlin" | mdat$species=="ruff", "dunlin/ruff", as.character(mdat$species)) # combine dunlin + ruff since only 1 obs of each
}
if (mgmtvars[i]=="mowing") {
# mdat$species <- ifelse(mdat$species=="dunlin" | mdat$species=="ruff" | mdat$species=="curlew", "dunlin/ruff/curlew", as.character(mdat$species)) # combine dunlin + ruff + curlew
mdat <- subset(mdat, species!="dunlin" & species!="ruff" & species!="curlew")
mdat <- subset(mdat, mowing!="applied")
}
if (mgmtvars[i]=="grazing") {
# mdat$species <- ifelse(mdat$species=="dunlin" | mdat$species=="ruff", "dunlin/ruff", as.character(mdat$species)) # combine dunlin + ruff since only 1 obs of each
mdat <- subset(mdat, species!="dunlin" & species!="ruff" & species!="curlew")
# mdat <- subset(mdat, grazing!="reduced")
# mdat <- subset(mdat, species!="snipe" & species!="curlew")
}
if (mgmtvars[i]=="fertpest") {
mdat <- subset(mdat, fertpest!="applied") # remove applied level as causes non-convergence even for bglmer model
mdat <- subset(mdat, species=="black-tailed godwit" | species=="lapwing") # model convergence issues when oyc and redshank are included
# mdat <- subset(mdat, species!="snipe" & species!="curlew" & species!="dunlin" & species!="ruff")
}
if (mgmtvars[i]=="nest.protect") {
mdat <- subset(mdat, species!="curlew" & species!="ruff") # 1 obs each; exclude rather than combine as interpretation for curlew/ruff combined doesn't make sense (too dissimilar in ecology)
}
if (mgmtvars[i]=="predator.control") {
# mdat <- subset(mdat, predator.control!="reduced")
mdat <- subset(mdat, species!="snipe" & species!="oystercatcher" & species!="redshank")
}
if (mgmtvars[i]=="water") {
mdat <- subset(mdat, species!="dunlin" & species!="ruff")
mdat <- subset(mdat, water!="reduced")
# model runs ok without 2 of curlew, oystercatcher and snipe, but model won't converge and has a very high max|grad| value when more than 1 of these species is included. Since they all have no successes for this management intervention and similar levels of failure, then combine together for the water analysis
mdat <- subset(mdat, species!="curlew" & species!="snipe")
# mdat$species <- ifelse(mdat$species=="curlew" | mdat$species=="snipe", "curlew/snipe", as.character(mdat$species))
}
mdat <- droplevels(mdat)
usedat[[i]] <- mdat
(checkzeros <- table(mdat[,mgmtvars[i]], mdat$species, mdat$success))
# create different formulas to use depending on whether management variable is 1 or 2 levels
if (length(levels(mdat[,mgmtvars[i]])) > 1) {
modform <- as.formula(paste("success ~ ", mgmtvars[i], "*species + (1|reference)", sep=""))
}
if (length(levels(mdat[,mgmtvars[i]])) < 2) {
modform <- as.formula("success ~ species + (1|reference)")
}
# run a normal glmer model
m.ind.sp[[i]] <- glmer(modform, data=mdat, family=binomial, control=glmerControl(optimizer="bobyqa"))
# if ANY checkzeros==0, then there are categories which are missing any observations whatsoever, so will have problems with complete separation and/or convergence
# use bglmer since there are some cases of singularity produced by 0/1 not having any observations for some of the categorical variables
# calculate the dimensions of the covariance matrix for bglmer, based on the dimensions of the covariance matrix from the regular glmer model
vcov.dim <- nrow(vcov(m.ind.sp[[i]]))
m.ind.sp.blme[[i]] <- bglmer(modform, data=mdat, family=binomial, fixef.prior = normal(cov = diag(9,vcov.dim)), control=glmerControl(optimizer="bobyqa"))
}
# m <- bglmer(success ~ species + lit.type + (1|reference), data=usedat[[1]], family=binomial, fixef.prior = normal(sd=3), control=glmerControl(optimizer="bobyqa"))
# anova(m,update(m,~.-species))
names(m.ind.sp) <- mgmtvars
names(m.ind.sp.blme) <- mgmtvars
names(usedat) <- mgmtvars
warningmessages.lme4 <- lapply(m.ind.sp, function(x) slot(x, "optinfo")$conv$lme4$messages)
warningmessages.lme4
warningmessages.blme <- lapply(m.ind.sp.blme, function(x) slot(x, "optinfo")$conv$lme4$messages)
warningmessages.blme
setwd(outputwd)
sink(paste("model output_0b.txt", sep=" "))
cat("\n########==========  0b) success of individual management types by species - BLME models (good) ==========########\n", sep="\n")
print(lapply(m.ind.sp.blme, summary))
cat("\n########==========  0b) success of individual management types by species - lme4 models (convergence issues) ==========########\n", sep="\n")
print(lapply(m.ind.sp, summary))
cat("\n########==========  Warning messages BLME models (good) ==========########\n", sep="\n")
print(warningmessages.blme)
cat("\n########==========  Warning messages lme4 models (convergence issues) ==========########\n", sep="\n")
print(warningmessages.lme4)
sink()
### Save individual interventions models
saveRDS(m.ind.sp.blme, file=paste(workspacewd, "models_0b_blme.rds", sep="/"))
saveRDS(m.ind.sp, file=paste(workspacewd, "models_0b_lme4.rds", sep="/"))
### Save dataset for 0b models
saveRDS(usedat, file=paste(workspacewd, "model dataset_0b.rds", sep="/"))
#=================================  SET LOGIC STATEMENTS  ====================
#=================================  LOAD PACKAGES =================================
list.of.packages <- c("MASS","reshape","raster","sp","rgeos","rgdal","lme4","car","blme","tidyr","nlme")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)
lapply(list.of.packages, library, character.only=TRUE)
#=================================  LOAD FUNCTIONS =================================
### Ben Bolker's function for calculating CIs on predictions from a merMod object and plotting the results from his RPubs GLMM worked examples
# http://rpubs.com/bbolker/glmmchapter
# by specifying re.form=NA we're saying that we want the population-level prediction, i.e. setting the random effects to zero and getting a prediction for an average (or unknown) group
# Computing confidence intervals on the predicted values is relatively easy if we're willing to completely ignore the random effects, and the uncertainty of the random effects
# this easy method produces similar width CIs to using the bootMer function in lme4, perhaps slightly wider CIs in some cases
# can change to alpha=0.16, approximately equal to 84% CIs
easyPredCI <- function(model,newdata,alpha=alphalevel) {
## baseline prediction, on the linear predictor (logit) scale:
pred0 <- predict(model,re.form=NA,newdata=newdata)
## fixed-effects model matrix for new data
X <- model.matrix(formula(model,fixed.only=TRUE)[-2],
newdata)
beta <- fixef(model) ## fixed-effects coefficients
V <- vcov(model)     ## variance-covariance matrix of beta
pred.se <- sqrt(diag(X %*% V %*% t(X))) ## std errors of predictions
## inverse-link (logistic) function: could also use plogis()
linkinv <- model@resp$family$linkinv
## construct 95% Normal CIs on the link scale and
##  transform back to the response (probability) scale:
crit <- -qnorm(alpha/2)
linkinv(cbind(lwr=pred0-crit*pred.se,
upr=pred0+crit*pred.se))
}
#=================================  SET DIRECTORY STRUCTURE  ================================
# LOCAL
if(.Platform$OS =='windows') {
cluster <- FALSE
Mac <- FALSE
}
# HPCBTO
if(.Platform$OS=='unix' & Sys.getenv('USER')=='samf') {
cluster <- TRUE
Mac <- FALSE
Wales <- FALSE
}
# Mac
if(.Platform$OS=='unix' & Sys.getenv('USER')=='samantha') {
cluster <- FALSE
Mac <- TRUE
Wales <- FALSE
}
#### SET DIRECTORY PATHS
# # Wales HPC cluster
# if (cluster) parentwd <- c("/home/samantha.franks/")
if (cluster) parentwd <- c("/users1/samf") # BTO cluster
if (!cluster) {
if (!Mac) parentwd <- c("C:/Users/samf/Documents/Git/eu_meadow_birds")
if (Mac) parentwd <- c("/Volumes/SAM250GB/BTO PC Documents/Git/eu_meadow_birds")
}
scriptswd <- paste(parentwd, "scripts", sep="/")
datawd <- paste(parentwd, "data", sep="/")
outputwd <- paste(parentwd, "output", sep="/")
workspacewd <- paste(parentwd, "workspaces", sep="/")
options(digits=6)
#=================================  LOAD DATA  ===============================
source(paste(scriptswd, "2_meta-analysis_data preparation.R", sep="/"))
#-----------------   HIGH-LEVEL INTERVENTION SUCCESS  ------------------
mdat <- subset(dat, high.int.used==1)
mdat <- droplevels(mdat)
newlevels <- data.frame(unique(mdat[,c("AE.level","reserve.desig")]), AE.reserve=c("AE.basic-no reserve","AE.higher-no reserve","no AE-reserve","AE.basic-reserve","AE.higher-reserve"))
mdat <- merge(mdat, newlevels, by=c("AE.level","reserve.desig"))
mdat$AE.reserve <- relevel(mdat$AE.reserve, ref="no AE-reserve")
print(levels(mdat$AE.reserve))
head(mdat)
m.high <- glmer(success ~ AE.reserve + species + (1|reference), data=mdat, family=binomial, control=glmerControl(optimizer="bobyqa"))
m.high <- glmer(success ~ AE*reserve.desig + species + (1|reference), data=mdat, family=binomial, control=glmerControl(optimizer="bobyqa"))
table(mdat$AE,mdat$reserve.desig)
summary(m.high)
m.high1 <- glmer(success ~ AE*reserve + species + (1|reference), data=dat, family=binomial, control=glmerControl(optimizer="bobyqa"))
m.high1 <- glmer(success ~ AE*reserve.desig + species + (1|reference), data=dat, family=binomial, control=glmerControl(optimizer="bobyqa"))
summary(m.high1)
mdat <- dat(species!="ruff")
mdat <- subset(dat, species!="ruff")
m.high1 <- glmer(success ~ AE*reserve.desig + species + (1|reference), data=mdat, family=binomial, control=glmerControl(optimizer="bobyqa"))
summary(m.high1)
rm(m.high)
drop1(m.high1, scope = ~AE*reserve.desig, test="Chisq")
drop1(m.high1, scope = ~AE:reserve.desig, test="Chisq")
mdat <- subset(dat, species!="ruff")
m.high <- glmer(success ~ AE*reserve.desig + species + (1|reference), data=mdat, family=binomial, control=glmerControl(optimizer="bobyqa"))
summary(m.high)
drop1(m.high, scope = ~AE:reserve.desig, test="Chisq")
setwd(outputwd)
sink(paste("model output_2a.txt", sep=" "))
cat("\n########==========  Success of higher-level interventions combined ==========########\n", sep="\n")
print(summary(m.high))
cat("\n###----  Significance of interaction term  ---###\n", sep="\n")
print(drop1(m.high, scope = ~AE:reserve.desig, test="Chisq"))
sink()
### Save individual interventions models
saveRDS(m.high, file=paste(workspacewd, "models_2a.rds", sep="/"))
### Save dataset for 0b models
saveRDS(mdat, file=paste(workspacewd, "model dataset_2a.rds", sep="/"))
# identify studies where a specific intervention is evaluated (could be in combination with others, and also with higher-level interventions)
# if any specific measure is used, then dat$spec.int.used=1, otherwise if all specific measures are 'none', then spec.int.used=0
# table(dat$spec.int.used)
# 0   1
# 242 351
# subset data to only use records where specific interventions were tested
mdat <- subset(dat, spec.int.used==1)
mdat <- droplevels(mdat)
# subset data to only use records where specific interventions were tested
mdat <- subset(dat, spec.int.used==1)
mdat <- subset(mdat, species!="ruff")
mdat <- droplevels(mdat)
m.spec <- glmer(success ~ mowing + grazing + fertpest + nest.protect + predator.control + water + species + (1|reference), data=mdat, family=binomial, control=glmerControl(optimizer="bobyqa"))
interventions.only <- mdat[,c("mowing","grazing","fertpest","nest.protect","predator.control","water")]
num.interventions <- ifelse(interventions.only=="none",0,1)
num.interventions.sum <- apply(num.interventions, 1, sum)
mdat <- data.frame(mdat, num.interventions.sum)
head(mdat)
m.spec <- glmer(success ~ mowing + grazing + fertpest + nest.protect + predator.control + water + species + num.interventions.sum + (1|reference), data=mdat, family=binomial, control=glmerControl(optimizer="bobyqa"))
str(mdat)
summary(m.spec)
m.spec <- glmer(success ~ mowing + grazing + fertpest + nest.protect + predator.control + water + species  + (1|reference), data=mdat, family=binomial, control=glmerControl(optimizer="bobyqa"))
summary(m.spec)
summary(m.high)
mdat <- subset(dat, high.int.used==1)
mdat <- droplevels(mdat)
newlevels <- data.frame(unique(mdat[,c("AE.level","reserve.desig")]), AE.reserve=c("AE.basic-no reserve","AE.higher-no reserve","no AE-reserve","AE.basic-reserve","AE.higher-reserve"))
mdat <- merge(mdat, newlevels, by=c("AE.level","reserve.desig"))
mdat$AE.reserve <- relevel(mdat$AE.reserve, ref="no AE-reserve")
print(levels(mdat$AE.reserve))
table(mdat$AE,mdat$reserve.desig)
m.high <- glmer(success ~ AE.reserve + species + (1|reference), data=mdat, family=binomial, control=glmerControl(optimizer="bobyqa"))
summary(m.high)
table(mdat$AE.reserve))
table(mdat$AE.reserve)
newlevels2 <- data.frame(unique(mdat[,c("AE.level","reserve.desig")]), AE.reserve2=c("AE.basic-no reserve","AE.higher-no reserve","no AE-reserve","AE.basic-reserve","AE.higher-reserve"))
mdat <- merge(mdat, newlevels2, by=c("AE.level","reserve.desig"))
mdat$AE.reserve <- relevel(mdat$AE.reserve2, ref="no AE-reserve")
table(mdat$AE.reserve2)
levels(mdat$AE.reserve2)
unique(mdat[,c("AE","reserve.desig")]
)
mdat <- subset(dat, high.int.used==1)
mdat <- droplevels(mdat)
newlevels <- data.frame(unique(mdat[,c("AE","reserve.desig")]), AE.reserve2=c("AE-reserve","AE-no reserve","no AE-reserve"))
mdat <- merge(mdat, newlevels, by=c("AE.level","reserve.desig"))
mdat$AE.reserve <- relevel(mdat$AE.reserve, ref="no AE-reserve")
table(mdat$AE.reserve)
newlevels2 <- data.frame(unique(mdat[,c("AE.level","reserve.desig")]), AE.reserve2=c("AE.basic-no reserve","AE.higher-no reserve","no AE-reserve","AE.basic-reserve","AE.higher-reserve"))
mdat <- merge(mdat, newlevels2, by=c("AE.level","reserve.desig"))
mdat$AE.reserve2 <- relevel(mdat$AE.reserve2, ref="no AE-reserve")
table(mdat$AE.reserve2)
m.high <- glmer(success ~ AE.reserve + species + (1|reference), data=mdat, family=binomial, control=glmerControl(optimizer="bobyqa"))
summary(m.high)
head(mdat)
mdat <- subset(dat, high.int.used==1)
mdat <- droplevels(mdat)
newlevels <- data.frame(unique(mdat[,c("AE","reserve.desig")]), AE.reserve=c("AE-reserve","AE-no reserve","no AE-reserve"))
mdat <- merge(mdat, newlevels, by=c("AE.level","reserve.desig"))
mdat$AE.reserve <- relevel(mdat$AE.reserve, ref="no AE-reserve")
table(mdat$AE.reserve)
newlevels2 <- data.frame(unique(mdat[,c("AE.level","reserve.desig")]), AE.reserve2=c("AE.basic-no reserve","AE.higher-no reserve","no AE-reserve","AE.basic-reserve","AE.higher-reserve"))
mdat <- merge(mdat, newlevels2, by=c("AE.level","reserve.desig"))
mdat$AE.reserve2 <- relevel(mdat$AE.reserve2, ref="no AE-reserve")
table(mdat$AE.reserve2)
mdat <- subset(dat, high.int.used==1)
mdat <- droplevels(mdat)
newlevels <- data.frame(unique(mdat[,c("AE","reserve.desig")]), AE.reserve=c("AE-reserve","AE-no reserve","no AE-reserve"))
newlevels
mdat <- merge(mdat, newlevels, by=c("AE","reserve.desig"))
mdat$AE.reserve <- relevel(mdat$AE.reserve, ref="no AE-reserve")
table(mdat$AE.reserve)
mdat[mdat$AE.reserve=="AE-reserve",]
mdat[mdat$AE.reserve=="AE-reserve",c("AE","reserve","AE.reserve","reference")]
mdat[mdat$AE.reserve=="AE-reserve",c("AE","reserve.desig","AE.reserve","reference")]
mdat <- subset(dat, high.int.used==1)
mdat <- droplevels(mdat)
unique(mdat[,c("AE","reserve.desig")])
mdat <- subset(dat, high.int.used==1)
mdat <- droplevels(mdat)
unique(mdat[,c("AE","reserve.desig")])
newlevels <- data.frame(unique(mdat[,c("AE","reserve.desig")]), AE.reserve=c("AE-no reserve","no AE-reserve","AE-reserve"))
mdat <- merge(mdat, newlevels, by=c("AE","reserve.desig"))
mdat$AE.reserve <- relevel(mdat$AE.reserve, ref="no AE-reserve")
table(mdat$AE.reserve)
newlevels2 <- data.frame(unique(mdat[,c("AE.level","reserve.desig")]), AE.reserve2=c("AE.basic-no reserve","AE.higher-no reserve","no AE-reserve","AE.basic-reserve","AE.higher-reserve"))
mdat <- merge(mdat, newlevels2, by=c("AE.level","reserve.desig"))
mdat$AE.reserve2 <- relevel(mdat$AE.reserve2, ref="no AE-reserve")
table(mdat$AE.reserve2)
m.high <- glmer(success ~ AE.reserve + species + (1|reference), data=mdat, family=binomial, control=glmerControl(optimizer="bobyqa"))
head(mdat)
mdat <- subset(dat, high.int.used==1)
mdat <- droplevels(mdat)
newlevels <- data.frame(AE=c("applied","none","applied"), reserve.desig=c("none","applied","applied"), AE.reserve=c("AE-no reserve","no AE-reserve","AE-reserve"))
mdat <- merge(mdat, newlevels, by=c("AE","reserve.desig"))
mdat$AE.reserve <- relevel(mdat$AE.reserve, ref="no AE-reserve")
table(mdat$AE.reserve)
newlevels2 <- data.frame(AE.level=c("basic","higher","none","basic","higher"), reserve.desig=c("none","none","applied","applied","applied"), AE.reserve2=c("AE.basic-no reserve","AE.higher-no reserve","no AE-reserve","AE.basic-reserve","AE.higher-reserve"))
mdat <- merge(mdat, newlevels2, by=c("AE.level","reserve.desig"))
mdat$AE.reserve2 <- relevel(mdat$AE.reserve2, ref="no AE-reserve")
table(mdat$AE.reserve2)
head(mdat)
m.high <- glmer(success ~ AE.reserve + species + (1|reference), data=mdat, family=binomial, control=glmerControl(optimizer="bobyqa"))
summary(m.high)
mdat <- subset(dat, high.int.used==1)
mdat <- subset(mdat, species!="ruff" & species!="dunlin")
mdat <- droplevels(mdat)
newlevels <- data.frame(AE=c("applied","none","applied"), reserve.desig=c("none","applied","applied"), AE.reserve=c("AE-no reserve","no AE-reserve","AE-reserve"))
mdat <- merge(mdat, newlevels, by=c("AE","reserve.desig"))
mdat$AE.reserve <- relevel(mdat$AE.reserve, ref="no AE-reserve")
table(mdat$AE.reserve)
newlevels2 <- data.frame(AE.level=c("basic","higher","none","basic","higher"), reserve.desig=c("none","none","applied","applied","applied"), AE.reserve2=c("AE.basic-no reserve","AE.higher-no reserve","no AE-reserve","AE.basic-reserve","AE.higher-reserve"))
mdat <- merge(mdat, newlevels2, by=c("AE.level","reserve.desig"))
mdat$AE.reserve2 <- relevel(mdat$AE.reserve2, ref="no AE-reserve")
table(mdat$AE.reserve2)
###--- Model ---###
m.high <- glmer(success ~ AE.reserve + species + (1|reference), data=mdat, family=binomial, control=glmerControl(optimizer="bobyqa"))
summary(m.high)
